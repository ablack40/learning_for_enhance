# 17. 堆内存与栈内存详解

## 1. 基本概念

在 C/C++ 等语言中，程序运行时主要使用的内存区域可以划分为几个部分，其中最核心的两个是**栈 (Stack)** 和**堆 (Heap)**。

*   **栈 (Stack):** 由编译器自动分配和释放，主要用于存放函数的参数值、局部变量等。其操作方式类似于数据结构中的栈（后进先出 LIFO）。栈内存分配运算内置于处理器的指令集中，效率很高，但容量有限。
*   **堆 (Heap):** 由程序员手动分配和释放（或由垃圾回收机制管理，如 Java/Python）。如果程序员不释放，程序结束时可能由操作系统回收。堆内存的分配方式类似于链表，不太连续，分配和释放需要库函数支持（如 `malloc`/`free`, `new`/`delete`），速度相对较慢，但可用空间通常远大于栈。

## 2. 堆与栈的主要区别

| 特性         | 栈 (Stack)                                  | 堆 (Heap)                                       |
| :----------- | :------------------------------------------ | :---------------------------------------------- |
| **分配/释放** | 编译器自动分配和释放                        | 程序员手动分配 (`new`/`malloc`) 和释放 (`delete`/`free`) |
| **管理方式** | 后进先出 (LIFO)，由操作系统/编译器严格管理 | 程序员管理（或 GC），容易产生内存泄漏或碎片     |
| **分配效率** | 非常高，通常是简单的指针移动                | 较低，涉及查找合适内存块、记录管理信息等        |
| **内存空间** | 通常较小（几 MB 到几十 MB，具体取决于系统） | 通常较大（取决于系统物理内存和虚拟内存）        |
| **内存连续性** | 通常是连续的内存区域                        | 通常是不连续的（碎片化）                        |
| **生长方向** | 通常向下增长（高地址 -> 低地址）            | 通常向上增长（低地址 -> 高地址）                |
| **生命周期** | 随函数调用开始和结束（或代码块作用域）      | 由程序员控制，直到手动释放或程序结束            |
| **存储内容** | 函数参数、局部变量、返回地址、函数上下文    | 动态分配的对象和数据（如 `new` 创建的对象）     |
| **访问速度** | 访问速度快                                  | 访问速度相对较慢                                |
| **错误类型** | 栈溢出 (Stack Overflow)                     | 内存泄漏 (Memory Leak)、野指针、重复释放等      |

## 3. C++ 代码示例：堆与栈的使用

```cpp
#include <iostream>
#include <string>
#include <vector>

// 全局变量 (存储在静态/全局存储区，不在堆也不在栈)
global_var = 100;
const char* global_string = "Hello from global";

class MyClass {
public:
    int id;
    std::string name;

    MyClass(int i, const std::string& n) : id(i), name(n) {
        std::cout << "MyClass constructor called for id: " << id << std::endl;
    }

    ~MyClass() {
        std::cout << "MyClass destructor called for id: " << id << std::endl;
    }

    void print() {
        std::cout << "ID: " << id << ", Name: " << name << std::endl;
    }
};

// 函数参数 arg_stack 存储在栈上
// 函数返回值（如果是对象且未使用 RVO/NRVO）可能临时存储在栈上
MyClass* createObjectOnHeap(int arg_stack) {
    // 局部变量 local_stack 存储在栈上
    int local_stack = arg_stack * 2;
    std::cout << "Local variable on stack: " << local_stack << std::endl;

    // 使用 new 在堆上分配 MyClass 对象
    // obj_ptr 本身 (指针变量) 存储在栈上
    // obj_ptr 指向的 MyClass 对象实例存储在堆上
    MyClass* obj_ptr = new MyClass(arg_stack, "Heap Object");

    return obj_ptr; // 返回指向堆内存的指针
}

int main() {
    // main 函数的参数 argc, argv 通常由操作系统准备，可能在栈或特定内存区域

    // 局部变量 main_local_stack 存储在栈上
    int main_local_stack = 10;

    // 栈上分配对象 stack_obj
    // stack_obj 对象本身直接存储在栈上
    MyClass stack_obj(main_local_stack, "Stack Object");
    std::cout << "Accessing stack object: ";
    stack_obj.print();

    // 调用函数，参数 5 传递到 arg_stack (栈)
    // 返回的指针 heap_ptr_stack 存储在 main 的栈帧上
    MyClass* heap_ptr_stack = createObjectOnHeap(5);

    // 通过存储在栈上的指针访问堆上的对象
    if (heap_ptr_stack != nullptr) {
        std::cout << "Accessing heap object via stack pointer: ";
        heap_ptr_stack->print();
    }

    // 动态分配数组在堆上
    // array_ptr_stack (指针) 存储在栈上
    // 指针指向的 10 个 int 的连续内存空间在堆上
    int* array_ptr_stack = new int[10];
    for (int i = 0; i < 10; ++i) {
        array_ptr_stack[i] = i * i; // 访问堆内存
    }
    std::cout << "Heap array element 3: " << array_ptr_stack[3] << std::endl;

    // 必须手动释放堆内存
    delete heap_ptr_stack;       // 释放堆上的 MyClass 对象，会调用析构函数
    heap_ptr_stack = nullptr;    // 良好习惯：指针置空

    delete[] array_ptr_stack;    // 释放堆上的数组
    array_ptr_stack = nullptr;

    std::cout << "Exiting main..." << std::endl;

    // main 函数结束时：
    // - main_local_stack (栈) 自动销毁
    // - stack_obj (栈) 自动销毁，调用其析构函数
    // - heap_ptr_stack (栈指针) 自动销毁
    // - array_ptr_stack (栈指针) 自动销毁
    // (堆上的内存在 delete 时已释放)

    return 0;
}

/*
总结存储位置：

栈 (Stack):
- 函数参数 (arg_stack, argc, argv - 具体实现可能不同)
- 局部变量 (local_stack, main_local_stack)
- 对象实例本身 (stack_obj)
- 指针变量本身 (obj_ptr, heap_ptr_stack, array_ptr_stack)
- **智能指针对象本身** (例如，在函数内声明的 `std::unique_ptr` 或 `std::shared_ptr` 变量)
- 函数调用的返回地址、寄存器状态等

堆 (Heap):
- new 创建的对象实例 (*obj_ptr 指向的内容, *heap_ptr_stack 指向的内容)
- new[] 创建的数组 (array_ptr_stack 指向的 int 数组)
- **智能指针管理的动态分配的对象** (例如 `std::make_unique` 或 `std::make_shared` 创建的对象)

静态/全局存储区:
- 全局变量 (global_var)
- 静态变量 (static variables)
- 字符串字面量 ("Hello from global", "Heap Object", "Stack Object" 等，通常在只读数据段)

代码段 (Text Segment):
- 编译后的程序指令
*/

## 4. 字节序 (Endianness) 与内存存储

**什么是字节序?**

字节序是指**多字节数据类型** (如 `int`, `float`, `short`, 指针地址等，即占用超过一个字节的数据) 在内存中存储时，其字节的排列顺序。

*   **大端序 (Big-Endian):** 高位字节 (Most Significant Byte, MSB) 存储在内存的低地址处，低位字节 (Least Significant Byte, LSB) 存储在内存的高地址处。类似于我们书写数字的方式（高位在前）。
*   **小端序 (Little-Endian):** 低位字节 (LSB) 存储在内存的低地址处，高位字节 (MSB) 存储在内存的高地址处。

**示例:** 假设有一个 32 位整数 `0x12345678` (十六进制)，在内存地址 `0x100` 开始存储：

*   **大端存储:**
    *   地址 `0x100`: `12` (MSB)
    *   地址 `0x101`: `34`
    *   地址 `0x102`: `56`
    *   地址 `0x103`: `78` (LSB)
*   **小端存储:**
    *   地址 `0x100`: `78` (LSB)
    *   地址 `0x101`: `56`
    *   地址 `0x102`: `34`
    *   地址 `0x103`: `12` (MSB)

**字节序与堆/栈的关系:**

**重要澄清:** 字节序是由 CPU 架构决定的，它影响的是**所有**内存区域（包括堆、栈、静态区等）中多字节数据的存储方式。**堆和栈本身并没有各自独立的字节序规则。** 无论数据是存储在堆上还是栈上，其多字节表示都会遵循当前系统架构的字节序。

例如，在一个小端架构的系统上，无论一个 `int` 变量是在栈上分配的局部变量，还是在堆上动态分配的，它的 4 个字节在内存中都会按照小端序排列。

**常见平台的字节序:**

*   **小端 (Little-Endian):**
    *   x86, x86-64 (Intel, AMD) - 这是绝大多数桌面和服务器 CPU
    *   ARM (绝大多数模式，如 iOS, Android 设备上的 ARMv7, ARMv8) - ARM 架构本身可以配置为大端或小端，但实际生态系统（如操作系统和工具链）通常默认或强制使用小端。
    *   DEC Alpha, VAX
*   **大端 (Big-Endian):**
    *   Motorola 68k, PowerPC (PPC) - 早期 Mac 使用 PowerPC，一些嵌入式系统和老服务器可能使用。
    *   SPARC (Oracle/Sun)
    *   网络字节序 (Network Byte Order): TCP/IP 协议栈规定网络传输使用大端序，因此不同字节序的主机间通信需要进行转换 (如使用 `htonl`, `ntohl` 等函数)。
*   **双端 (Bi-Endian):**
    *   一些现代 ARM 架构、MIPS、PowerPC 等可以配置为大端或小端模式运行。

**如何判断当前系统的字节序?**

```cpp
#include <iostream>

int main() {
    union {
        uint32_t i;
        char c[4];
    } test_union;

    test_union.i = 0x01020304; // 假设 int 是 32 位

    if (test_union.c[0] == 0x04) {
        std::cout << "System is Little-Endian." << std::endl;
    } else if (test_union.c[0] == 0x01) {
        std::cout << "System is Big-Endian." << std::endl;
    } else {
        std::cout << "Could not determine endianness." << std::endl;
    }

    return 0;
}
```

这个程序利用联合体 (union) 的特性：所有成员共享同一块内存。我们将一个 32 位整数存入 `i`，然后检查这块内存的第一个字节 (`c[0]`)。如果是整数的最低位字节 (`0x04`)，则系统是小端；如果是最高位字节 (`0x01`)，则是大端。
